<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bindings (owl-opt-lbfgs.Owl_opt_lbfgs__.Bindings)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">owl-opt-lbfgs</a> &#x00BB; <a href="../index.html">Owl_opt_lbfgs__</a> &#x00BB; Bindings</nav><h1>Module <code>Owl_opt_lbfgs__.Bindings</code></h1></header><aside><p>Binding to <a href="http://users.eecs.northwestern.edu/~nocedal/lbfgsb.html">L-BFGS-B</a>. These is a limited-memory quasi-Newton code for unconstrained and for bound-constrained optimization.</p><p>This is a modified version of the OCaml bindings written by</p><p>Christophe Troestler &lt;Christophe.Troestler@umons.ac.be&gt; WWW: http://math.umons.ac.be/an/software/</p><p>Please refer to https://github.com/Chris00/L-BFGS-ocaml for details.</p><p>The authors of the original FORTRAN code expect that if you use their software in a publication, you quote one of these references:</p><ul><li>R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound Constrained Optimization, (1995), SIAM Journal on Scientific and Statistical Computing , 16, 5, pp. 1190-1208.</li><li>C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B, FORTRAN routines for large scale bound constrained optimization (1997), ACM Transactions on Mathematical Software, Vol 23, Num. 4, pp. 550-560.</li><li>J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B, FORTRAN routines for large scale bound constrained optimization (2011), to appear in ACM Transactions on Mathematical Software.</li></ul><dl><dt>version</dt><dd>%%VERSION%%</dd></dl></aside><dl><dt class="spec type" id="type-work"><a href="#type-work" class="anchor"></a><code><span class="keyword">type</span> work</code></dt><dd><p>Represent the memory space needed to solve a minimization problem. It is usually allocated automatically but it is possible to do it manually to, say, allocate it once only before a loop.</p></dd></dl><dl><dt class="spec exception" id="exception-Abnormal"><a href="#exception-Abnormal" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Abnormal</span> <span class="keyword">of</span> float * string</code></dt><dd><p><code>Abnormal(f, msg)</code> is raised if the routine terminated abnormally without being able to satisfy the termination conditions. In such an event, the variable <code>x</code> (see <span class="xref-unresolved" title="unresolved reference to &quot;F.min&quot;"><code>F</code>.min</span>) will contain the current best approximation found and <code>f</code> is the value of the target function at <code>x</code>. <code>msg</code> is a message containing additional information (returned by the original FORTRAN code).</p><p>If the error message is not precise enough, it is recommended to turn printing on to understand what is the problem.</p></dd></dl><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code></dt><dd><p>Holds informations on the current state of the computation that can help to decide whether to stop.</p></dd></dl><dl><dt class="spec type" id="type-vec"><a href="#type-vec" class="anchor"></a><code><span class="keyword">type</span> vec</code><code> = <span><span>(float, Stdlib.Bigarray.float64_elt, Stdlib.Bigarray.c_layout)</span> Stdlib.Bigarray.Array1.t</span></code></dt><dd><p>Vectors.</p></dd></dl><dl><dt class="spec type" id="type-lbfgs_status"><a href="#type-lbfgs_status" class="anchor"></a><code><span class="keyword">type</span> lbfgs_status</code><code> = </code><table class="variant"><tr id="type-lbfgs_status.Stop" class="anchored"><td class="def constructor"><a href="#type-lbfgs_status.Stop" class="anchor"></a><code>| </code><code><span class="constructor">Stop</span> <span class="keyword">of</span> float</code></td></tr><tr id="type-lbfgs_status.Continue" class="anchored"><td class="def constructor"><a href="#type-lbfgs_status.Continue" class="anchor"></a><code>| </code><code><span class="constructor">Continue</span> <span class="keyword">of</span> float</code></td></tr></table></dt><dd><p>Lbfgs Status</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span>?&#8288;factr:float</span> <span>&#45;&gt;</span> <span>?&#8288;pgtol:float</span> <span>&#45;&gt;</span> <span>work:<a href="index.html#type-work">work</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-lbfgs_status">lbfgs_status</a></code></dt><dd><p><code>min f_df x df</code> minimises the function <code>f</code> given by <code>f_df</code>. <code>x</code> is an initial estimate of the solution vector. On termination, <code>x</code> will contain the next approximation found and <code>df</code> will contain the latest gradient. <code>min f_df x df</code> should be called iteratively to find the minimum of <code>f</code>. <code>f_df x df</code> is a function that computes f(x) and its gradiant f'(x), returns f(x) and stores f'(x) in <code>df</code>. The <code>x</code> passed to <code>f_df x df</code> is physically equal to the <code>x</code> given in <code>min f_df x</code>. Can raise <a href="index.html#exception-Abnormal"><code>Abnormal</code></a>.</p><dl><dt>parameter factr</dt><dd><p>tolerance in the termination test for the algorithm. The iteration will stop when <code>(f^k - f^{k+1})/max{ |f^k|, |f^{k+1}|, 1} &lt;= factr*epsilon_float</code>. Set e.g. <code>factr</code> to <code>1e12</code> for low accuracy, <code>1e7</code> for moderate accuracy and <code>1e1</code> for extremely high accuracy. Setting <code>factr</code> to <code>0.</code> suppresses this termination test. Default: <code>1e7</code>.</p></dd></dl><dl><dt>parameter pgtol</dt><dd><p>The iteration will stop when <code>max{ |proj g_i| : i = 0,..., n-1} &lt;= pgtol</code> where <code>proj g_i</code> is the ith component of the projected gradient. Setting <code>pgtol</code> to <code>0.</code> suppresses this termination test. Default: <code>1e-5</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span>?&#8288;factr:float</span> <span>&#45;&gt;</span> <span>?&#8288;pgtol:float</span> <span>&#45;&gt;</span> <span>work:<a href="index.html#type-work">work</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-lbfgs_status">lbfgs_status</a></code></dt><dd><p><code>max f_df x</code> maximises the function <code>f</code> given by <code>f_df</code>. <code>x</code> is an initial estimate of the solution vector. This function is provided for convenience and calls <span class="xref-unresolved" title="unresolved reference to &quot;F.min&quot;"><code>F</code>.min</span> to which the reader is referred for further explanations.</p></dd></dl><dl><dt class="spec value" id="val-start"><a href="#val-start" class="anchor"></a><code><span class="keyword">val</span> start : <span>?&#8288;corrections:int</span> <span>&#45;&gt;</span> <span>?&#8288;l:<a href="index.html#type-vec">vec</a></span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="index.html#type-vec">vec</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-work">work</a></code></dt><dd><p><code>start n</code> allocate the work space for a problem of size at most <code>n</code>.</p><dl><dt>parameter l</dt><dd><p>lower bound for each component of the vector <code>x</code>. Set <code>l.(i)</code> to <code>neg_infinity</code> to indicate that no lower bound is desired. Default: no lower bounds.</p></dd></dl><dl><dt>parameter u</dt><dd><p>upper bound for each component of the vector <code>x</code>. Set <code>u.(i)</code> to <code>infinity</code> to indicate that no upper bound is desired. Default: no upper bounds.</p></dd></dl><dl><dt>parameter corrections</dt><dd><p>maximum number of variable metric corrections used to define the limited memory matrix. Values &lt; 3 are not recommended, and large values of <code>corrections</code> can result in excessive computing time. The range 3 &lt;= <code>corrections</code> &lt;= 20 is recommended. Default: <code>10</code>. This value in called <code>M</code> in L-BFGS-B debugging output.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-restart"><a href="#val-restart" class="anchor"></a><code><span class="keyword">val</span> restart : <a href="index.html#type-work">work</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>restart state</code> restarts the L-BFGS-B optimization.</p></dd></dl></div></body></html>